;----------------------------------------------------------;
;                       dyn_eval_noform.scm                ;
;----------------------------------------------------------;
; Author : Yoann                                           ;
; Created : Sun May 13 2014                                ;
; Last modification : Sun May 14 21:19:00 2017             ;
; Ã‰valuateur Dynamique                                     ;
;----------------------------------------------------------;

(module dyn-eval-noform)

(define the-false-value (cons "false" "boolean"))
(define empty 813)
(define env.init '())

(define (atom? x)
   (not (pair? x)))

(define (eprogn exps env)
   (if (pair? exps)
       (if (pair? (cdr exps))
	   (let ((result (evaluate (car exps) env)))
	     (let ((value (car result))
		   (env (cdr result)))
	       (eprogn (cdr exps) env)))
	 (evaluate (car exps) env))
     (cons empty env)))

(define (extend env variable value)
  (cons (cons variable value) env))

(define (lookup id env)
   (if (pair? env)
       (if (eq? (caar env) id)
	    (cdar env)
	   (lookup id (cdr env)))
       (error "lookup" "no such binding" id)))

(define (update id env v)
  (extend env id v))

(define (evaluate exp env)
  (if (atom? exp)
      (cond ((symbol? exp) (cons (lookup exp env) env))
	    ((or (number? exp) (string?	exp) (char? exp) (boolean? exp) (vector? exp))
	     (cons exp env))
	    (else (error "evaluate" "cannot evaluate" exp)))
    (case (car exp)
      ((quote) 
       (cons (cadr exp) env))
      ((if)
       (let ((result (evaluate (cadr exp) env)))
	 (let ((value (car result))
	       (cond-env (cdr result)))
	   (if (not (equal? value the-false-value))
	       (evaluate (caddr exp) env)
	       (evaluate (cadddr exp) env)))))
      ((begin)
       (eprogn (cdr exp) env))
      ((set) 
       (let ((result (evaluate (caddr exp) env)))
	 (let ((value (car result))
	       (env (cdr result)))
	   (cons empty (update (cadr exp) env value)))))
      ((let) 
       (let ((result (evaluate (cadadr exp) env)))
	 (let ((value (car result))
	       (let-env (cdr result)))
	   (eprogn (cddr exp) (extend env (caadr exp) value)))))
      ((service) 
       (cons (make-service (caadr exp) (cddr exp) env) env))
      ((listen)
       (let ((server-socket (make-server-socket 8080)))
	 (let loop ((client-socket (socket-accept server-socket)))
	   (let* ((client-in-port (socket-input client-socket))
		  (client-out-port (socket-output client-socket))
		  (first-line (string-split (read-line client-in-port)))
		  (method (string->symbol (car first-line)))
		  (uri (string->symbol (car (string-split (cadr first-line) "?"))))
		  (arg (cadr (string-split (cadr (string-split (cadr first-line) "?")) "="))))
	     (print arg)
	     (let ((service (lookup uri env)))
	       (display (car (service arg env)) client-out-port)
	       (flush-output-port client-out-port)
	       (socket-close client-socket)
	       (socket-shutdown client-socket)
	       (loop (socket-accept server-socket)))))))
      ((lambda) 
       (cons (make-closure (caadr exp) (cddr exp) env) env))
      ((function) 
       (cons (make-function (caadr exp) (cddr exp) env) env))
      ((string-append)
       (let loop ((strings (cdr exp))
		  (res ""))
	 (if (pair? strings)
	     (loop (cdr strings) (string-append res (car (evaluate (car strings) env))))
	     (cons res env))))
      ((+) 
       (let ((result (evaluate (cadr exp) env)))
	 (let ((left-value (car result))
	       (left-env (cdr result)))
	   (let ((result (evaluate (caddr exp) env)))
	     (let ((right-value (car result))
		   (right-env (cdr result)))
	       (cons (+ left-value right-value)
		     env))))))
      (else 
       (let ((result (evaluate (car exp) env)))
	 (let ((f (car result))
	       (env (cdr result)))
	   (let ((result (evaluate (cadr exp) env)))
	     (let ((value (car result))
		   (env (cdr result)))
	       (invoke f value env)))))))))

(define (invoke fn arg dyn-env)
   (if (procedure? fn)
       (fn arg dyn-env)
       (error "invoke" "not a procedure" fn)))

(define (make-service variable body env)
   (lambda (value dyn-env)
      (eprogn body (extend env variable value))))

(define (make-closure variable body env)
   (lambda (value dyn-env)
      (eprogn body (extend env variable value))))

(define (make-function variable body env)
   (lambda (value dyn-env)
      (eprogn body (extend dyn-env variable value))))

(let loop ((exprs '((1 (let (a 1) a))
		    ;;((3 4) (let (a 2) (let (a 3) (let (b 4) (list a b)))))
		    (12 (let (f (lambda (x) x)) (f 12)))
		    (12 (let (f (function (x) x)) (f 12)))
		    (3 (let (x 0)
			  (let (fl (lambda (a) (+ x a)))
			    (let (ff (function (a) (+ x a)))
			      (set x 1)
			      (+ (fl 1) (ff 1))))))
		    (3 (let (x 0)
			  (let (fl (lambda (a) (+ x a)))
			    (let (ff (function (a) (+ x a)))
			      (set x 1)
			      (+ (ff 1) (fl 1))))))
		    (0 (let (/hello (service (name) (string-append "HTTP/1.1 200 OK\nContent-Type:text/html\nConnection:Close\n\n<html><body>" name "</body></html>\n"))) (listen)))
		    )))
     (if (pair? exprs)
	 (let ((expected-result (caar exprs))
	       (expression (cadar exprs)))
	  (let ((result (evaluate expression env.init)))
	    (let ((value (car result))
		  (env (cdr result)))
	      (if (equal? value expected-result)
		  (begin
		   (print expression)
		   (print "evaluates to")
		   (print value))
		(error "assert false" result (car (car exprs))))))
	  (loop (cdr exprs)))))

;(0 (service /hello 8080 (name) name))
;(0 (let (/hello (service (name) name)) (serve /hello)))

; (let-service (/hello (name) (service /inc (n) (+ n 1)) name)
; (service /hello 8080 (name) name))
; (let (/hello (service (name) name)) (serve /hello))
; (let (/hello (service (name) name)) (let (/inc (service (n) (+ n 1))) (listen)))
; (serve /hello (service (name) name))
; (let (/hello (service (name) name)) (listen))
